# ACH-safe Charset

ACH files are allowed to use only a subset of US-ASCII consisting of printable characters.
This character set ensures that no disallowed characters are encoded or decoded.

Java `Charset` can be configured for one of three different actions when it encounters an error encoding or decoding
a character:

Java character encoders and decoders can be configured for different actions when encounter a coding error:

1. Report, which in most cases results in a `CharacterCodingException`
2. Replace, which replaces the unknown code with a predefined placeholder
3. Ignore, which causes the output to be shorter

The default is to replace the character, which is often the best approach. ACH files have a fixed-width record
format, so ignoring errors by skipping characters may cause downstream processing to fail. Reporting errors with an
exception may lead to an unrecoverable error requiring manual intervention.

## Read Examples

### Length-preserving reads of an ACH input stream

If an input stream that is expected to contain only characters allowed by ACH encounters an unexpected value, the
best approach may be to substitute a replacement character into the stream and allow processing to continue.
Reporting the error with an exception could abort and delay the entire file ingestion stage due to a single field
on a single record. Ignoring the error by skipping over the unexpected character may cause an offset that breaks
subsequent processing of a fixed-width field. Substituting a placeholder allows processing to continue.

```Java
InputStream bytesIn = new FileInputStream("achfile");
// Charset can be passed by name because it has a provider resource in the classpath
Reader reader = new InputStreamReader(bytesIn, "ACH");
// reader will replace unexpected bytes with '?' characters
```

### Forcing failure if the input contains *any* unexpected characters

If an input stream that is expected to contain only characters allowed by ACH encounters an unexpected value, it
can be configured to report the error with an exception. This prevents missing or replacement characters being
passed, which ensures that only completely clean inputs continue processing.

```Java
InputStream bytesIn = new FileInputStream("input.ach");
// Retrieve Charset by name because it has a provider resource in the classpath
Charset ACH = Charset.forName("ACH");
// Obtain an explicit decoder and override the default behavior on malformed input
CharsetDecoder decoder = ACH.newDecoder().onMalformedInput(CodingErrorAction.REPORT);
// Use the constructor that accepts a CharsetDecoder
Reader reader = new InputStreamReader(bytesIn, decoder);
// reader will throw an exception if it encounters an unexpected byte
```

## Write Examples

### Length-preserving writes to an ACH output stream

ACH files require each record to be 94 characters. The critical fields necessary for processing a file are usually
generated by well-tested templates. A template may include text fields from a source that contains a wider range
of characters than ACH allows. Injecting an unexpected character could cause problems for downstream systems.
Reporting the error with an exception could abort and delay the entire file generation stage due to a single field
on a single record. The best solution in this case is to replace the unexpected character.

```Java
OutputStream bytesOut = new FileOutputStream("output.ach");
// Charset can be passed by name because it has a provider resource in the classpath
Writer writer = new OutputStreamWriter(bytesOut, "ACH");
// writer will replaced unexpected characters with '?'
```

### Forcing failure if the output contains *any* unexpected characters

If a single bad character is considered sufficient cause to abort generation of an ACH file, the encoding can be
configured to throw an exception rather than continuing. In this case, the default behavior of the `Encoder` must
be overridden with an alternative action.

```Java
OutputStream bytesOut = new FileOutputStream("output.ach");
// Retrieved Charset by name because it has a provider resource in the classpath
Charset ACH = Charset.forName("ACH");
// Obtain an explicit encoder and override the default behavior on unmappable output
CharsetEncoder encoder = ACH.newEncoder().onUnmappableCharacter(CodingErrorAction.REPORT);
// Use the constructor that accepts a CharsetEncoder
Writer writer = new OutputStreamWriter(bytesOut, encoder);
// reader will throw an exception if it encounters an unexpected character
```